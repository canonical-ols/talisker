##
## Copyright (c) 2015-2018 Canonical, Ltd.
## 
## Permission is hereby granted, free of charge, to any person obtaining a copy of
## this software and associated documentation files (the "Software"), to deal in
## the Software without restriction, including without limitation the rights to
## use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
## of the Software, and to permit persons to whom the Software is furnished to do
## so, subject to the following conditions:
## 
## The above copyright notice and this permission notice shall be included in all
## copies or substantial portions of the Software.
## 
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
## OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.
##
"""
This is an internal test tool to construct a requirements.txt with dependencies
pinned to the miniumum supported versions, for use with tox.
"""
from __future__ import print_function
import os
import sys
import argparse

from setuptools.config import read_configuration
try:
    # pip>=10
    from pip._internal.req.req_file import parse_requirements
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.download import PipSession
except ImportError:
    # pip<10
    from pip.req.req_file import parse_requirements
    from pip.req.req_file import InstallRequirement
    from pip.download import PipSession


def get_source(comes_from):
    index = comes_from.find(' (line ')
    if index != -1:
        comes_from = comes_from[:index]
    if comes_from.startswith('-r '):
        comes_from = comes_from[3:]
    return comes_from


def print_file(filename, requirements):
    file = None
    for requirement in requirements:
        if not requirement.match_markers():
            continue

        comes_from = get_source(requirement.comes_from)
        if comes_from != file:
            if file is not None:
                print()
            print('# ' + comes_from)
            file = comes_from

        found = False
        specs = [(r.version, r) for r in requirement.specifier]
        if specs:
            version, spec = min(specs)
            if version in spec:
                found = True
                print('{}=={}'.format(requirement.name, version))
            else:
                print('# no explicit minimum')
        if not found:
            print(str(requirement.req))
    print()


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("requirements", nargs="*")
    parser.add_argument("--extras", default="")

    args = parser.parse_args()
    session = PipSession()
    options = {}

    print('# AUTOGENERATED by {}\n# DO NOT EDIT\n#\n'.format(sys.argv[0]))

    if os.path.exists('setup.cfg'):
        options = read_configuration('setup.cfg').get('options', {})

    install_requires = options.get('install_requires', [])
    extras_require = options.get('extras_require', {})

    if install_requires:
        fname = 'setup.cfg:options.install_requires'
        print_file(
            fname,
            (InstallRequirement.from_line(l, fname) for l in
                sorted(install_requires)),
        )

    for extra, requires in sorted(extras_require.items()):
        if extra in args.extras:
            fname = 'setup.cfg:options.extras_require:' + extra
            print_file(
                fname,
                (InstallRequirement.from_line(l, fname) for l in
                    sorted(requires)),
            )

    for filename in args.requirements:
        print_file(filename, parse_requirements(filename, session=session))
